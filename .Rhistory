inverseMatrix <<-matrixInv
}
getMatrixInverse <- function() inverseMatrix
list(setMatrix = setMatrix, getMatrix= getMatrix,
setMatrixInverse = setMatrixInverse, getMatrixInverse = getMatrixInverse)
}
## Write a short comment describing this function
### This function first accesses the Inverse of the matrix and
### if it NULL then it calculates the matrix inverse by using solve function.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
matrixInv <-x$getMatrixInverse()
if(is.na(matrixInv) ){
message("Calculating Matrix Inverse ")
matrixInv<<-solve(x$getMatrix())
}
matrixInv
}
matx <- makeCacheMatrix(mat)
cacheSolve(matx)
matx$getMatrix()
solve(matx$getMatrix())
solve(matx$getMatrix())
pp<- matrix()
pp
pp <- solve(matx$getMatrix())
pp
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
# Set the inverse to be NULL
inverseMatrix <<-matrix()
# function definition for seting the matrix
setMatrix <- function(y){
x<<-y
inverseMatrix <<-matrix()
}
# function definition for geting the matrix
getMatrix <- function() x
# function definition for storing the matrix inverse
setMatrixInverse <- function(matrixInv){
inverseMatrix <<-matrixInv
}
getMatrixInverse <- function() inverseMatrix
list(setMatrix = setMatrix, getMatrix= getMatrix,
setMatrixInverse = setMatrixInverse, getMatrixInverse = getMatrixInverse)
}
## Write a short comment describing this function
### This function first accesses the Inverse of the matrix and
### if it NULL then it calculates the matrix inverse by using solve function.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
matrixInv <-x$getMatrixInverse()
if(is.na(matrixInv) ){
message("Calculating Matrix Inverse ")
matrixInv<<-solve(x$getMatrix())
}
matrixInv
}
matx <- makeCacheMatrix(mat)
cacheSolve(matx)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
# Set the inverse to be NULL
inverseMatrix <<-matrix()
# function definition for seting the matrix
setMatrix <- function(y){
x<<-y
inverseMatrix <<-matrix()
}
# function definition for geting the matrix
getMatrix <- function() x
# function definition for storing the matrix inverse
setMatrixInverse <- function(matrixInv){
inverseMatrix <<-matrixInv
}
getMatrixInverse <- function() inverseMatrix
list(setMatrix = setMatrix, getMatrix= getMatrix,
setMatrixInverse = setMatrixInverse, getMatrixInverse = getMatrixInverse)
}
## Write a short comment describing this function
### This function first accesses the Inverse of the matrix and
### if it NULL then it calculates the matrix inverse by using solve function.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
matrixInv <-x$getMatrixInverse()
if(is.na(matrixInv) ){
message("Calculating Matrix Inverse ")
inverseMat <-solve(x$getMatrix())
print(inverseMat)
}
matrixInv
}
matx <- makeCacheMatrix(mat)
cacheSolve(matx)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
# Set the inverse to be NULL
inverseMatrix <<-matrix()
# function definition for seting the matrix
setMatrix <- function(y){
x<<-y
inverseMatrix <<-matrix()
}
# function definition for geting the matrix
getMatrix <- function() x
# function definition for storing the matrix inverse
setMatrixInverse <- function(matrixInv){
inverseMatrix <<-matrixInv
}
getMatrixInverse <- function() inverseMatrix
list(setMatrix = setMatrix, getMatrix= getMatrix,
setMatrixInverse = setMatrixInverse, getMatrixInverse = getMatrixInverse)
}
## Write a short comment describing this function
### This function first accesses the Inverse of the matrix and
### if it NULL then it calculates the matrix inverse by using solve function.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
matrixInv <-x$getMatrixInverse()
if(is.na(matrixInv) ){
message("Calculating Matrix Inverse ")
inverseMat <-solve(x$getMatrix())
matrixInv <<- inverseMat
}
matrixInv
}
matx <- makeCacheMatrix(mat)
cacheSolve(matx)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
# Set the inverse to be NULL
inverseMatrix <<-matrix()
# function definition for seting the matrix
setMatrix <- function(y){
x<<-y
inverseMatrix <<-matrix()
}
# function definition for geting the matrix
getMatrix <- function() x
# function definition for storing the matrix inverse
setMatrixInverse <- function(matrixInv){
inverseMatrix <<-matrixInv
}
getMatrixInverse <- function() inverseMatrix
list(setMatrix = setMatrix, getMatrix= getMatrix,
setMatrixInverse = setMatrixInverse, getMatrixInverse = getMatrixInverse)
}
## Write a short comment describing this function
### This function first accesses the Inverse of the matrix and
### if it NULL then it calculates the matrix inverse by using solve function.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
matrixInv <-x$getMatrixInverse()
if(is.na(matrixInv) ){
message("Calculating Matrix Inverse ")
inverseMat <-solve(x$getMatrix())
matrixInv <<- inverseMat
}
print(inverseMat)
}
matx <- makeCacheMatrix(mat)
cacheSolve(matx)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
# Set the inverse to be NULL
inverseMatrix <<-matrix()
# function definition for seting the matrix
setMatrix <- function(y){
x<<-y
inverseMatrix <<-matrix()
}
# function definition for geting the matrix
getMatrix <- function() x
# function definition for storing the matrix inverse
setMatrixInverse <- function(matrixInv){
inverseMatrix <<-matrixInv
}
getMatrixInverse <- function() inverseMatrix
list(setMatrix = setMatrix, getMatrix= getMatrix,
setMatrixInverse = setMatrixInverse, getMatrixInverse = getMatrixInverse)
}
## Write a short comment describing this function
### This function first accesses the Inverse of the matrix and
### if it NULL then it calculates the matrix inverse by using solve function.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
matrixInv <-x$getMatrixInverse()
if(is.na(matrixInv) ){
message("Calculating Matrix Inverse ")
inverseMat <-solve(x$getMatrix())
x$setMatrixInverse(inverseMat)
}
x$getMatrixInverse()
}
matx <- makeCacheMatrix(mat)
cacheSolve(matx)
cacheSolve(matx)
cacheSolve(matx)
cacheSolve(matx)
matx$getMatrixInverse()
pp <- matrix()
pp
is.matrix(pp)
is.na(pp)
is.na()
is.na(pp)
pp <- matrix(,2,2)
pp
is.na(pp)
matrix(TRUE,2:2)
matrix(TRUE,2,2)
dim(pp)
matrix(TRUE,dim(pp))
matrix(TRUE,dim(pp)[1])
matrix(TRUE,dim(pp)[1],dim(pp)[2])
pp <- matrix()
dim(pp)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
# Set the inverse to be NULL
inverseMatrix <<-matrix()
# function definition for seting the matrix
setMatrix <- function(y){
x<<-y
inverseMatrix <<-matrix()
}
# function definition for geting the matrix
getMatrix <- function() x
# function definition for storing the matrix inverse
setMatrixInverse <- function(matrixInv){
inverseMatrix <<-matrixInv
}
getMatrixInverse <- function() inverseMatrix
list(setMatrix = setMatrix, getMatrix= getMatrix,
setMatrixInverse = setMatrixInverse, getMatrixInverse = getMatrixInverse)
}
## Write a short comment describing this function
### This function first accesses the Inverse of the matrix and
### if it NULL then it calculates the matrix inverse by using solve function.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
matrixInv <-x$getMatrixInverse()
if(is.na(matrixInv)==matrix(TRUE,dim(matrixInv)[1],dim(matrixInv)[2]) ){
message("Calculating Matrix Inverse ")
inverseMat <-solve(x$getMatrix())
x$setMatrixInverse(inverseMat)
}
x$getMatrixInverse()
}
matx<- makeCacheMatrix(mat)
mat
cacheSolve(matx)
cacheSolve(matx)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
# Set the inverse to be NULL
inverseMatrix <<-matrix()
# function definition for seting the matrix
setMatrix <- function(y){
x<<-y
inverseMatrix <<-matrix()
}
# function definition for geting the matrix
getMatrix <- function() x
# function definition for storing the matrix inverse
setMatrixInverse <- function(matrixInv){
inverseMatrix <<-matrixInv
}
getMatrixInverse <- function() inverseMatrix
list(setMatrix = setMatrix, getMatrix= getMatrix,
setMatrixInverse = setMatrixInverse, getMatrixInverse = getMatrixInverse)
}
## Write a short comment describing this function
### This function first accesses the Inverse of the matrix and
### if it NULL then it calculates the matrix inverse by using solve function.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
matrixInv <-x$getMatrixInverse()
if(is.na(matrixInv)==matrix(TRUE,dim(matrixInv)[1],dim(matrixInv)[2])) {
message("Calculating Matrix Inverse ")
inverseMat <-solve(x$getMatrix())
x$setMatrixInverse(inverseMat)
}
x$getMatrixInverse()
}
matx<- makeCacheMatrix(mat)
cacheSolve(matx)
cacheSolve(matx)
pp
pp = matrix(2,2)
isTRUE(all.equal(is.na(pp),matrix(TRUE,2,2))
)
isTRUE(all.equal(is.na(pp),matrix(TRUE,2,2)))
isTRUE(all.equal(is.na(pp),matrix(TRUE,2,2))){}
isTRUE(all.equal(is.na(pp),matrix(TRUE,2,2))){ print("yes")}
}
isTRUE(all.equal(is.na(pp),matrix(TRUE,2,2))){ print("yes")
isTRUE(all.equal(is.na(pp),matrix(TRUE,2,2)))
if(isTRUE(all.equal(is.na(pp),matrix(TRUE,2,2))) == TRUE)
{}
if(isTRUE(all.equal(is.na(pp),matrix(TRUE,2,2))) == TRUE){print(yes)}
if(isTRUE(all.equal(is.na(pp),matrix(TRUE,2,2))) == TRUE){print("yes")}
if(isTRUE(all.equal(is.na(pp),matrix(TRUE,2,2))) == TRUE){print("yes")}
pp
pp = matrix(2,2)
pp
pp = matrix(,2,2)
pp = matrix(,2,2)
pp
if(isTRUE(all.equal(is.na(pp),matrix(TRUE,2,2))) == TRUE){print("yes")}
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
# Set the inverse to be NULL
inverseMatrix <<-matrix()
# function definition for seting the matrix
setMatrix <- function(y){
x<<-y
inverseMatrix <<-matrix()
}
# function definition for geting the matrix
getMatrix <- function() x
# function definition for storing the matrix inverse
setMatrixInverse <- function(matrixInv){
inverseMatrix <<-matrixInv
}
getMatrixInverse <- function() inverseMatrix
list(setMatrix = setMatrix, getMatrix= getMatrix,
setMatrixInverse = setMatrixInverse, getMatrixInverse = getMatrixInverse)
}
## Write a short comment describing this function
### This function first accesses the Inverse of the matrix and
### if it NULL then it calculates the matrix inverse by using solve function.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
matrixInv <-x$getMatrixInverse()
if(isTRUE(all.equal(is.na(matrixInv),
matrix(TRUE,dim(matrixInv)[1],dim(matrixInv)[2])))) {
message("Calculating Matrix Inverse ")
inverseMat <-solve(x$getMatrix())
x$setMatrixInverse(inverseMat)
}
x$getMatrixInverse()
}
matx<- makeCacheMatrix(mat)
cacheSolve(matx)
cacheSolve(matx)
cacheSolve(matx)
cacheSolve(matx)
cacheSolve(matx)
cacheSolve(matx)
cacheSolve(matx)
mat
mat <- matrix(1,3,4,8,0,9,2,3)
mat <- matrix(1:6,2,3)
mat
matx<- makeCacheMatrix(mat)
cacheSolve(matx)
mat <- matrix(1:9,3,3)
mat
matx<- makeCacheMatrix(mat)
cacheSolve(matx)
mat
solve(mat)
combinedata
mat <- matrix(1:1,3,3)
matx<- makeCacheMatrix(mat)
cacheSolve(matx)
mat
solve(mat)
mat[2][3]
mat[2,3]
mat[2,3]<-4
mat
solve(mat)
mat[1,1]<-4
solve(mat)
matx<- makeCacheMatrix(mat)
cacheSolve(matx)
cacheSolve(matx)
cacheSolve(matx)
cacheSolve(matx)
cacheSolve(matx)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
# Set the inverse to be NULL
inverseMatrix <<-matrix()
# function definition for seting the matrix
setMatrix <- function(y){
x<<-y
inverseMatrix <<-matrix()
}
# function definition for geting the matrix
getMatrix <- function() x
# function definition for storing the matrix inverse
setMatrixInverse <- function(matrixInv){
inverseMatrix <<-matrixInv
}
getMatrixInverse <- function() inverseMatrix
list(setMatrix = setMatrix, getMatrix= getMatrix,
setMatrixInverse = setMatrixInverse, getMatrixInverse = getMatrixInverse)
}
## Write a short comment describing this function
### This function first accesses the Inverse of the matrix and
### if it NULL then it calculates the matrix inverse by using solve function.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
matrixInv <-x$getMatrixInverse()
if(isTRUE(all.equal(is.na(matrixInv),
Qmatrix(TRUE,dim(matrixInv)[1],dim(matrixInv)[2])))) {
message("Calculating Matrix Inverse ")
inverseMat <-solve(x$getMatrix())
x$setMatrixInverse(inverseMat)
}
x$getMatrixInverse()
}
matx<- makeCacheMatrix(mat)
cacheSolve(matx)
mat
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
# Set the inverse to be NULL
inverseMatrix <<-matrix()
# function definition for seting the matrix
setMatrix <- function(y){
x<<-y
inverseMatrix <<-matrix()
}
# function definition for geting the matrix
getMatrix <- function() x
# function definition for storing the matrix inverse
setMatrixInverse <- function(matrixInv){
inverseMatrix <<-matrixInv
}
getMatrixInverse <- function() inverseMatrix
list(setMatrix = setMatrix, getMatrix= getMatrix,
setMatrixInverse = setMatrixInverse, getMatrixInverse = getMatrixInverse)
}
## Write a short comment describing this function
### This function first accesses the Inverse of the matrix and
### if it NULL then it calculates the matrix inverse by using solve function.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
matrixInv <-x$getMatrixInverse()
if(isTRUE(all.equal(is.na(matrixInv),
Qmatrix(TRUE,dim(matrixInv)[1],dim(matrixInv)[2])))) {
message("Calculating Matrix Inverse ")
inverseMat <-solve(x$getMatrix())
x$setMatrixInverse(inverseMat)
}
x$getMatrixInverse()
}
cacheSolve(matx)
## Put comments here that give an overall description of what your
## functions do
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
# Set the inverse to be NULL
inverseMatrix <<-matrix()
# function definition for seting the matrix
setMatrix <- function(y){
x<<-y
inverseMatrix <<-matrix()
}
# function definition for geting the matrix
getMatrix <- function() x
# function definition for storing the matrix inverse
setMatrixInverse <- function(matrixInv){
inverseMatrix <<-matrixInv
}
getMatrixInverse <- function() inverseMatrix
list(setMatrix = setMatrix, getMatrix= getMatrix,
setMatrixInverse = setMatrixInverse, getMatrixInverse = getMatrixInverse)
}
## Write a short comment describing this function
### This function first accesses the Inverse of the matrix and
### if it NULL then it calculates the matrix inverse by using solve function.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
matrixInv <-x$getMatrixInverse()
if(isTRUE(all.equal(is.na(matrixInv),
matrix(TRUE,dim(matrixInv)[1],dim(matrixInv)[2])))) {
message("Calculating Matrix Inverse ")
inverseMat <-solve(x$getMatrix())
x$setMatrixInverse(inverseMat)
}
x$getMatrixInverse()
}
cacheSolve(matx)
cacheSolve(matx)
cacheSolve(matx)
cacheSolve(matx)
clearPushBack()
